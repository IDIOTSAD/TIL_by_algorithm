# 문제풀면서 고민했던 점

* 클래스 2부터 슬슬 생각을 하면서 풀어야 한다.
* 처음부터 몇시간이 걸린 문제도 존재하여 어렵게 풀었던 문제들을 기록하고자 한다.

## 1018 문제 - https://www.acmicpc.net/problem/1018
* 평균 시도 횟수가 2.1이라니 믿기지 않는다!
* 해당 문제를 풀기 위해서 처음 고안했던 방법으로는 왼쪽 상단 꼭짓점의 이동을 통해서 움직이면서 일일히 검사하는 것이었다.
* 위 방법을 이용 할 수 있었던 이유는 어느 방향에서의 꼭짓점에서 8칸이 되도록 이동하기 때문임.
* (0,0) 부분에서 각 행, 열의 이동을 통한 8칸 생성이나 (0, N), (N, 0), (N, N)에서나 같기 때문이다.

* 예시)

![image](https://user-images.githubusercontent.com/55529455/183272121-3fc00709-5791-478e-ae7c-0d16714bc8a3.png)


* 8칸을 검사할 생각으로는 생성된 (i,j)에서 (i+8, j+8)까지 대각선으로 이동하면서 위 아래로 검사하는 방법을 이용하였다.
* 해당 방법을 이용한 이유는 한 점을 기준으로 했을 때, 상하좌우로 홀수 위치의 경우 다르고, 짝수 위치의 경우는 같은 점을 이용하였음.
* 또한, 대각선으로는 항상 값이 같다는 점을 이용하여 문제를 해결하였음.
* 나름의 생각이지만, 이렇게 검사하게 된다면 기존의 완전탐색보다 시간을 절약 할 수 있다고 생각한다.
* 왜냐하면, 이중 for문에서 1개를 보지 않고, 2개를 보기 때문이다.
* 따라서 대각이동을 하는 n번과, (n ~ 0) 까지의 반복이 진행되기 때문에, 기존의 n^2의 알고리즘이 아닌, n log n이라고 생각이 들었다.

* 검정선은 검사하는 프로세스고, 빨간선은 이동하는 선이다.

![image](https://user-images.githubusercontent.com/55529455/183272210-658e1fd9-5e4e-47ab-88aa-fb2d478c5daa.png)

## 1181 문제 - https://www.acmicpc.net/problem/1181
* 해당 문제를 풀기 위해서 sort에 대해서 알 필요가 있었다.
* sort 함수의 경우, 문자열을 sort 할 때는, 단어의 크기 (알파벳 순서)로 정렬한다는 점을 알고 있어야 한다.
* 따라서, lambda 함수를 주어 길이에 맞추어 정렬하는 내용을 추가 해주어야 한다. (lambda x: len(x))
* 순서 : 알파벳 순서로 정렬 한 후, 길이 수에 맞추어 정렬하면 해결 됨.

---
### 문제 출처
* https://solved.ac/class/2e
